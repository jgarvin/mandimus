from Actions import Key
from rules.ContextualRule import makeContextualRule
from requirements.Emacs import IsEmacs
from requirements.ModeRequirement import ModeRequirement
from rules.emacs.common import emacsExtras, emacsDefaults
from rules.emacs.Cmd import Cmd
from rules.emacs.Keywords import KeywordRule

keywords = [
    "always",
    "end",
    "ifnone",
    "or",
    "rpmos",
    "tranif1",
    "and",
    "endcase",
    "initial",
    "output",
    "rtran",
    "tri",
    "assign",
    "endmodule",
    "inout",
    "parameter",
    "rtranif0",
    "tri0",
    "begin",
    "endfunction",
    "input",
    "pmos",
    "rtranif1",
    "tri1",
    "buf",
    "endprimitive",
    "integer",
    "posedge",
    "scalared",
    "triand",
    "bufif0",
    "endspecify",
    "join",
    "primitive",
    "small",
    "trior",
    "bufif1",
    "endtable",
    "large",
    "pull0",
    "specify",
    "trireg",
    "case",
    "endtask",
    "macromodule",
    "pull1",
    "specparam",
    "vectored",
    "casex",
    "event",
    "medium",
    "pullup",
    "strong0",
    "wait",
    "casez",
    "for",
    "module",
    "pulldown",
    "strong1",
    "wand",
    "cmos",
    "force",
    "nand",
    "rcmos",
    "supply0",
    "weak0",
    "deassign",
    "forever",
    "negedge",
    "real",
    "supply1",
    "weak1",
    "default",
    "for",
    "nmos",
    "realtime",
    "table",
    "while",
    "defparam",
    "function",
    "nor",
    "reg",
    "task",
    "wire",
    "disable",
    "highz0",
    "not",
    "release",
    "time",
    "wor",
    "edge",
    "highz1",
    "notif0",
    "repeat",
    "tran",
    "xnor",
    "else",
    "if",
    "notif1",
    "rnmos",
    "tranif0",
    "xor"
]
#
VerilogKeywordRule = KeywordRule(["verilog-mode"], keywords)

_mapping = {
}

VerilogRule = makeContextualRule("verilog", _mapping, emacsExtras, emacsDefaults)
VerilogRule.context.addRequirement(IsEmacs)
VerilogRule.context.addRequirement(ModeRequirement(modes=["verilog-mode"]))
